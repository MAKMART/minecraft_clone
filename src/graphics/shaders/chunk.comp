#version 460 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

const ivec3 CHUNK_SIZE = ivec3(16, 16, 16);
uniform uvec3 chunkOffset;

struct Block {
    uint value;
};

struct Face {
    uvec3 position;
    uint  face_id;
    uint  block_type;
};

layout(std430, binding = 1) readonly buffer BlockBuffer {
    Block blocks[];
};

layout(std430, binding = 2) buffer FaceBuffer {
    Face faces[];
};

layout(std430, binding = 3) buffer FaceCounter {
    uint face_count;
};
layout(std430, binding = 4) buffer IndirectBuffer {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
} indirect;


uint get_block(uint idx) {
    uint element = blocks[idx / 4].value;
    uint shift   = (idx % 4u) * 8u;
    return (element >> shift) & 0xFFu;
}

uint get_index(uint x, uint y, uint z) {
    return x
         + y * CHUNK_SIZE.x
         + z * CHUNK_SIZE.x * CHUNK_SIZE.y;
}
bool is_face_visible(ivec3 p, ivec3 dir) {
    ivec3 n = p + dir;

    if (any(lessThan(n, ivec3(0))) ||
        any(greaterThanEqual(n, CHUNK_SIZE)))
        return true;

    uint neighbor = get_block(get_index(n.x, n.y, n.z));
    return neighbor == 0u; // AIR
}
ivec3 dirs[6] = ivec3[](
		ivec3( 0,  0,  1), // front
		ivec3( 0,  0, -1), // back
		ivec3(-1,  0,  0), // left
		ivec3( 1,  0,  0), // right
		ivec3( 0,  1,  0), // top
		ivec3( 0, -1,  0)  // bottom
		);
void main() {
	ivec3 p = ivec3(gl_GlobalInvocationID);

	if (any(greaterThanEqual(p, CHUNK_SIZE)))
		return;

	uint block_index = get_index(p.x, p.y, p.z);
	uint block_type = get_block(block_index);
	if (block_type == 0u)
		return;

	for (uint face = 0; face < 6; ++face) {
		if (!is_face_visible(p, dirs[face]))
			continue;

		uint dst = atomicAdd(face_count, 1);

		faces[dst].position   = uvec3(p);
		//faces[dst].position = uvec3(p) + chunkOffset;
		faces[dst].face_id    = face;
		faces[dst].block_type = block_type;
	}
	// Finish all atomic increments
	barrier();                     // ensures workgroup sync
	memoryBarrierBuffer();         // ensure SSBO writes are visible


	// Only one thread writes indirect buffer after all faces are counted
	if (all(equal(gl_GlobalInvocationID, uvec3(0)))) {
		indirect.count = face_count * 6u;
		indirect.instanceCount = 1u;
		indirect.first = 0u;
		indirect.baseInstance = 0u;
	}
}
