#version 460 core
layout(local_size_x = 256) in;

struct Block {
	uint type;
};
layout(std430, binding = 1) readonly buffer voxel_buffer {
    uint voxels[];
};
layout(std430, binding = 2) readonly buffer face_flags {
    uint flags[]; // 1 = visible, 0 = hidden
};

// Input: exclusive prefix sum for each face
layout(std430, binding = 5) readonly buffer prefix_sums {
    uint prefix[]; // maps visible faces to face_ssbo indices
};

// Output: face_ssbo, one FaceGPU per visible face
struct FaceGPU {
    uint packed_value;
};
layout(std430, binding = 7) writeonly buffer face_ssbo {
    FaceGPU faces[];
};

// Uniforms
uniform uvec3 CHUNK_SIZE;
uniform uint total_faces;

ivec3 dirs[6] = ivec3[](
    ivec3(0,0,1),  ivec3(0,0,-1),
    ivec3(-1,0,0), ivec3(1,0,0),
    ivec3(0,1,0),  ivec3(0,-1,0)
);

// Get voxel type from packed uint
uint get_voxel(uint idx) {
    uint element = voxels[idx / 4u];
    uint shift   = (idx % 4u) * 8u;
    return (element >> shift) & 0xFFu;
}
uint get_index(uint x, uint y, uint z) {
	return x + (y * CHUNK_SIZE.x) + (z * CHUNK_SIZE.x * CHUNK_SIZE.y);
}

uint pack_face(uint voxel_index, uint face_id, uint block_type)
{
	return
		(voxel_index) |
		(face_id << 18) |
		(block_type << 21);
}

uint unpack_voxel_index(uint p)
{
	return p & ((1u << 18) - 1u);
}

uint unpack_face_id(uint p)
{
	return (p >> 18) & 7u;
}

uint unpack_block_type(uint p)
{
	return (p >> 21) & 255u;
}

bool get_flag(uint index)
{
    uint word = flags[index >> 5];
    return ((word >> (index & 31u)) & 1u) != 0u;

}
void main() {
    uint gid = gl_GlobalInvocationID.x;

    if (gid >= total_faces) return;
    //if (get_flag(gid) == 0u) return; // skip invisible faces
	if (!get_flag(gid)) return;

    // Index in the output face_ssbo
    uint out_idx = prefix[gid];

    uint voxel_idx = gid / 6u;
    uint face_id   = gid % 6u;

	uint block_type = get_voxel(voxel_idx);
	faces[out_idx].packed_value = pack_face(voxel_idx, face_id, block_type);
}
